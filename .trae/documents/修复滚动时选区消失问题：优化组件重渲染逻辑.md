
用户反馈的问题是“一动页面，弹出的选中窗口就消失了，并且选择范围也会消失”。这通常是因为滚动事件触发了某些状态更新，导致组件重绘或者选区被清除。

在 `NodeDetailView.tsx` 中，我注意到 `handleScroll` 使用 `requestAnimationFrame` 更新 `toolbarPosition`。但是，在 React 中，如果 `updateToolbarPosition` 内部依赖于 `window.getSelection()`，而滚动时 `selection` 对象可能会发生变化或者变得不稳定，尤其是在某些浏览器行为下。

更关键的是，`handleScroll` 只是更新了工具栏位置，但如果用户是在滚动页面，选区本身应该保持不变。

然而，我怀疑问题可能出在 `onMouseUp` 和 `onKeyUp` 事件处理上。现在的逻辑是：
1. `onMouseUp` / `onKeyUp` 触发 `handleTextSelection`。
2. `handleTextSelection` 使用 `setTimeout` 延迟获取选区。
3. 如果选区存在，设置 `selectedText` 和 `toolbarPosition`。

当用户滚动时，`useEffect` 里的 `handleScroll` 会被触发。
```typescript
    const handleScroll = () => {
      if (selectedText) {
        // 使用 requestAnimationFrame 优化性能
        requestAnimationFrame(updateToolbarPosition)
      }
    }
```
`updateToolbarPosition` 会重新计算位置。如果此时 `window.getSelection()` 返回的选区因为滚动而发生变化（或者因为某些原因 range 变为 collapsed），`updateToolbarPosition` 里的逻辑会清空状态：
```typescript
        if (rect.width === 0 || rect.height === 0) {
          setToolbarPosition(null) // <--- 这里可能会被触发
          return
        }
```
或者：
```typescript
      } else {
        setToolbarPosition(null)
      }
    } else {
      setToolbarPosition(null)
    }
```

**问题分析**：
当页面滚动时，选区相对于视口的位置会改变。如果选区滚出了视口，`rect.top` 等属性会变化。虽然我在 `updateToolbarPosition` 里加了视口检查，但可能逻辑过于敏感，导致稍微一动就隐藏了工具栏。

另外，还有一个潜在问题：`selectedText` 状态更新可能会导致组件重新渲染。如果组件重新渲染，且 `ReactMarkdown` 没有被正确记忆（memoized），它可能会重新生成 DOM，从而导致浏览器清除选区。
查看代码：
```typescript
              <ReactMarkdown
                key={node.id}
                remarkPlugins={[remarkGfm, remarkBreaks]}
                components={{ ... }}
              >
                {node.contentMd}
              </ReactMarkdown>
```
`ReactMarkdown` 的 `components` 属性是一个对象字面量，每次 `NodeDetailView` 渲染时都会创建一个新的对象。这会导致 `ReactMarkdown` 认为组件配置变了，从而可能触发不必要的重渲染。虽然 `ReactMarkdown` 内部可能有优化，但最佳实践是将 `components` 提到组件外或使用 `useMemo`。

**修复计划**：
1.  **稳定 `components` 定义**：将 `ReactMarkdown` 的 `components` 定义提取到组件外部或使用 `useMemo` 包裹，防止因父组件重渲染导致 Markdown 内容 DOM 重建（这是选区消失的最常见原因）。
2.  **优化滚动逻辑**：
    *   在滚动时，不应该轻易清除选区状态，除非选区真的不存在了。
    *   `updateToolbarPosition` 应该只在选区仍然有效时更新位置，如果选区滚出视口，可以选择隐藏工具栏但不清除 `selectedText`，或者让工具栏跟随滚动。
    *   目前逻辑是：如果 `selectedText` 存在，就尝试更新位置。如果 `window.getSelection()` 拿不到有效选区，就设为 `null`。这可能太激进。
3.  **防止选区丢失**：确保 `NodeDetailView` 的重渲染不会导致 DOM 结构变化从而丢失选区。

**具体步骤**：
1.  使用 `useMemo` 缓存 `components` 对象。
2.  检查 `key={node.id}` 是否必要，如果 `node` 对象引用变化但 ID 没变，是否会触发重渲染。
3.  修改 `updateToolbarPosition` 逻辑，增加对选区有效性的宽容度，或者在滚动时仅更新位置而不清除状态（除非选区真的没了）。

我将优先处理 **`components` 对象的 memoization**，因为这是导致选区在滚动或状态更新时消失的最根本原因（DOM 刷新导致选区丢失）。
